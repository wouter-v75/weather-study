<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Historical Weather Data Map</title>
  
  <!-- Tailwind CSS -->
  <script src="https://cdn.tailwindcss.com"></script>
  
  <!-- Leaflet CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  
  <!-- Leaflet JS -->
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  
  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
  
  <style>
    body {
      margin: 0;
      padding: 0;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;
    }
    #root {
      width: 100%;
      height: 100vh;
    }
    .chart-container {
      position: relative;
      height: 100%;
      width: 100%;
    }
  </style>
</head>
<body>
  <div id="root">
    <div class="w-full h-screen flex flex-col bg-gray-50">
      <div class="bg-white shadow-sm border-b p-4">
        <h1 class="text-2xl font-bold text-gray-800">Historical Weather Data Map</h1>
        <p class="text-sm text-gray-600 mt-1">Select points and analyze wind speed patterns by month across years</p>
      </div>

      <div class="flex flex-1 overflow-hidden">
        <div class="w-1/3 border-r bg-white overflow-y-auto">
          <div class="p-4 space-y-4">
            <div>
              <h2 class="font-semibold text-lg mb-2">Selected Points (<span id="pointCount">0</span>/3)</h2>
              <div id="pointsList" class="space-y-2">
                <p class="text-sm text-gray-500">Click on the map to add points</p>
              </div>
            </div>

            <div class="border-t pt-4">
              <h2 class="font-semibold text-lg mb-3">Time Period</h2>
              <div class="space-y-3">
                <div>
                  <label class="block text-sm font-medium mb-1">Year Range</label>
                  <div class="flex gap-2 items-center">
                    <input
                      type="number"
                      id="startYear"
                      value="2020"
                      min="1940"
                      max="2024"
                      class="w-full px-3 py-2 border rounded focus:ring-2 focus:ring-blue-500 outline-none"
                    />
                    <span class="text-gray-500">to</span>
                    <input
                      type="number"
                      id="endYear"
                      value="2024"
                      min="1940"
                      max="2024"
                      class="w-full px-3 py-2 border rounded focus:ring-2 focus:ring-blue-500 outline-none"
                    />
                  </div>
                </div>
                <div>
                  <label class="block text-sm font-medium mb-1">Month</label>
                  <select
                    id="selectedMonth"
                    class="w-full px-3 py-2 border rounded focus:ring-2 focus:ring-blue-500 outline-none"
                  >
                    <option value="01">January</option>
                    <option value="02">February</option>
                    <option value="03">March</option>
                    <option value="04">April</option>
                    <option value="05">May</option>
                    <option value="06">June</option>
                    <option value="07">July</option>
                    <option value="08">August</option>
                    <option value="09">September</option>
                    <option value="10">October</option>
                    <option value="11">November</option>
                    <option value="12">December</option>
                  </select>
                </div>
              </div>
            </div>

            <div class="border-t pt-4">
              <h2 class="font-semibold text-lg mb-3">Daily Time Window</h2>
              <div class="space-y-3">
                <div>
                  <label class="block text-sm font-medium mb-1">Time Zone</label>
                  <select
                    id="timezone"
                    class="w-full px-3 py-2 border rounded focus:ring-2 focus:ring-blue-500 outline-none"
                  >
                    <option value="Europe/Berlin">CET (Central European Time)</option>
                    <option value="UTC">UTC (Coordinated Universal Time)</option>
                    <option value="Europe/London">GMT (Greenwich Mean Time)</option>
                    <option value="America/New_York">EST (Eastern Standard Time)</option>
                    <option value="America/Chicago">CST (Central Standard Time)</option>
                    <option value="America/Denver">MST (Mountain Standard Time)</option>
                    <option value="America/Los_Angeles">PST (Pacific Standard Time)</option>
                    <option value="Asia/Tokyo">JST (Japan Standard Time)</option>
                    <option value="Australia/Sydney">AEST (Australian Eastern Time)</option>
                    <option value="auto">Auto (Location-based)</option>
                  </select>
                </div>
                <div>
                  <label class="block text-sm font-medium mb-1">Start Time</label>
                  <input
                    type="time"
                    id="startTime"
                    value="10:00"
                    class="w-full px-3 py-2 border rounded focus:ring-2 focus:ring-blue-500 outline-none"
                  />
                </div>
                <div>
                  <label class="block text-sm font-medium mb-1">End Time</label>
                  <input
                    type="time"
                    id="endTime"
                    value="18:00"
                    class="w-full px-3 py-2 border rounded focus:ring-2 focus:ring-blue-500 outline-none"
                  />
                </div>
                <p class="text-xs text-gray-600">
                  Data will be averaged between <span id="displayStartTime">10:00</span> and <span id="displayEndTime">18:00</span> each day
                </p>
              </div>
            </div>

            <button
              id="fetchBtn"
              onclick="fetchWeatherData()"
              class="w-full bg-blue-600 text-white py-2 px-4 rounded hover:bg-blue-700 disabled:bg-gray-400 disabled:cursor-not-allowed font-medium"
            >
              Fetch Weather Data
            </button>
          </div>
        </div>

        <div class="flex-1 flex flex-col overflow-hidden">
          <div id="map" class="flex-1" style="min-height: 300px;"></div>
          
          <div id="chartsContainer" class="flex-1 bg-white border-t overflow-y-auto" style="display: none;">
            <div class="p-4 space-y-6">
              <div>
                <h2 class="font-semibold text-lg mb-2" id="avgChartTitle">Average Wind Speed at 10m (knots) by Day of Month</h2>
                <p class="text-xs text-gray-600 mb-2">Shaded areas show range of yearly averages. Dotted lines show instantaneous min/max within time window.</p>
                <div style="height: 300px;">
                  <canvas id="avgChart"></canvas>
                </div>
              </div>
              
              <div class="border-t pt-4">
                <h2 class="font-semibold text-lg mb-2">Wind Speed Distribution at 10m (knots)</h2>
                <div style="height: 300px;">
                  <canvas id="distChart"></canvas>
                </div>
              </div>
              
              <div class="border-t pt-4">
                <h2 class="font-semibold text-lg mb-2">Wind Rose (Direction & Speed Frequency)</h2>
                <p class="text-xs text-gray-600 mb-2">Polar charts showing wind direction frequency and speed distribution for each location</p>
                <div id="windRoseContainer" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                  <!-- Wind rose charts will be added here dynamically -->
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // Global state
    let map = null;
    let points = [];
    let markers = [];
    let weatherData = [];
    let avgChart = null;
    let distChart = null;
    let windRoseCharts = [];
    const colors = ['#3b82f6', '#ef4444', '#10b981'];

    // Initialize map
    function initMap() {
      map = L.map('map').setView([37, 15], 5);
      
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: 'Â© OpenStreetMap contributors'
      }).addTo(map);

      map.on('click', function(e) {
        if (points.length < 3) {
          const newPoint = {
            lat: e.latlng.lat,
            lng: e.latlng.lng,
            id: Date.now(),
            name: `Point ${points.length + 1}`
          };
          
          const marker = L.marker([e.latlng.lat, e.latlng.lng])
            .addTo(map)
            .bindPopup(`Point ${points.length + 1}<br>Lat: ${e.latlng.lat.toFixed(4)}<br>Lng: ${e.latlng.lng.toFixed(4)}`)
            .openPopup();
          
          markers.push(marker);
          points.push(newPoint);
          updatePointsList();
        }
      });
    }

    function updatePointsList() {
      const pointsList = document.getElementById('pointsList');
      const pointCount = document.getElementById('pointCount');
      pointCount.textContent = points.length;

      if (points.length === 0) {
        pointsList.innerHTML = '<p class="text-sm text-gray-500">Click on the map to add points</p>';
      } else {
        pointsList.innerHTML = points.map((point, idx) => `
          <div class="flex items-center justify-between p-2 bg-gray-50 rounded">
            <div class="flex-1">
              <div class="font-medium" style="color: ${colors[idx]}">${point.name}</div>
              <div class="text-xs text-gray-600">${point.lat.toFixed(4)}, ${point.lng.toFixed(4)}</div>
            </div>
            <button onclick="removePoint(${point.id})" class="text-red-500 hover:text-red-700 text-sm px-2 py-1">
              Remove
            </button>
          </div>
        `).join('');
      }
    }

    function removePoint(id) {
      const index = points.findIndex(p => p.id === id);
      if (index !== -1) {
        map.removeLayer(markers[index]);
        markers.splice(index, 1);
        points.splice(index, 1);
        weatherData = weatherData.filter(d => d.pointId !== id);
        updatePointsList();
        if (weatherData.length > 0) {
          updateCharts();
        } else {
          document.getElementById('chartsContainer').style.display = 'none';
          windRoseCharts.forEach(chart => chart.destroy());
          windRoseCharts = [];
        }
      }
    }

    function isTimeInRange(timeStr, startTime, endTime) {
      const hour = parseInt(timeStr.split('T')[1].split(':')[0]);
      const startHour = parseInt(startTime.split(':')[0]);
      const endHour = parseInt(endTime.split(':')[0]);
      return hour >= startHour && hour <= endHour;
    }

    function getDaysInMonth(month) {
      const days = {
        '01': 31, '02': 29, '03': 31, '04': 30, '05': 31, '06': 30,
        '07': 31, '08': 31, '09': 30, '10': 31, '11': 30, '12': 31
      };
      return days[month];
    }

    async function fetchWeatherData() {
      if (points.length === 0) {
        alert('Please select at least one point on the map');
        return;
      }

      const btn = document.getElementById('fetchBtn');
      btn.disabled = true;
      btn.textContent = 'Loading...';

      const startYear = parseInt(document.getElementById('startYear').value);
      const endYear = parseInt(document.getElementById('endYear').value);
      const selectedMonth = document.getElementById('selectedMonth').value;
      const startTime = document.getElementById('startTime').value;
      const endTime = document.getElementById('endTime').value;
      const timezone = document.getElementById('timezone').value;

      document.getElementById('displayStartTime').textContent = startTime;
      document.getElementById('displayEndTime').textContent = endTime;

      weatherData = [];

      try {
        for (const point of points) {
          for (let year = startYear; year <= endYear; year++) {
            const daysInMonth = getDaysInMonth(selectedMonth);
            const startDate = `${year}-${selectedMonth}-01`;
            const endDate = `${year}-${selectedMonth}-${daysInMonth}`;

            const url = `https://archive-api.open-meteo.com/v1/archive?latitude=${point.lat}&longitude=${point.lng}&start_date=${startDate}&end_date=${endDate}&hourly=windspeed_10m,wind_direction_10m&timezone=${timezone}`;
            
            const response = await fetch(url);
            const data = await response.json();

            if (data.hourly) {
              const filteredData = data.hourly.time
                .map((time, idx) => ({
                  time,
                  wind: data.hourly.windspeed_10m[idx],
                  direction: data.hourly.wind_direction_10m[idx]
                }))
                .filter(item => isTimeInRange(item.time, startTime, endTime));

              filteredData.forEach(item => {
                const date = item.time.split('T')[0];
                const dayOfMonth = parseInt(date.split('-')[2]);
                
                // Convert km/h to knots (1 km/h = 0.539957 knots)
                const windSpeedKnots = item.wind * 0.539957;
                
                weatherData.push({
                  pointId: point.id,
                  pointName: point.name,
                  year: year,
                  dayOfMonth: dayOfMonth,
                  windSpeed: windSpeedKnots,
                  windDirection: item.direction
                });
              });
            }
          }
        }

        document.getElementById('chartsContainer').style.display = 'block';
        updateCharts();
      } catch (error) {
        alert('Error fetching weather data: ' + error.message);
      } finally {
        btn.disabled = false;
        btn.textContent = 'Fetch Weather Data';
      }
    }

    function updateCharts() {
      const startTime = document.getElementById('startTime').value;
      const endTime = document.getElementById('endTime').value;
      const startYear = parseInt(document.getElementById('startYear').value);
      const endYear = parseInt(document.getElementById('endYear').value);
      const monthName = document.getElementById('selectedMonth').selectedOptions[0].text;

      // Calculate average, max, and min wind speed by day of month for each point
      // Also calculate yearly averages for error bars
      const avgByDay = {};
      const maxByDay = {};
      const minByDay = {};
      const yearlyAvgByDay = {}; // For error bars: {pointName: {day: [year1Avg, year2Avg, ...]}}
      
      points.forEach(point => {
        avgByDay[point.name] = {};
        maxByDay[point.name] = {};
        minByDay[point.name] = {};
        yearlyAvgByDay[point.name] = {};
        
        for (let day = 1; day <= 31; day++) {
          const dayData = weatherData.filter(d => 
            d.pointId === point.id && d.dayOfMonth === day
          );
          
          if (dayData.length > 0) {
            const speeds = dayData.map(d => d.windSpeed);
            avgByDay[point.name][day] = speeds.reduce((sum, s) => sum + s, 0) / speeds.length;
            maxByDay[point.name][day] = Math.max(...speeds);
            minByDay[point.name][day] = Math.min(...speeds);
            
            // Calculate yearly averages for error bars
            const yearlyAvgs = [];
            for (let year = startYear; year <= endYear; year++) {
              const yearDayData = dayData.filter(d => d.year === year);
              if (yearDayData.length > 0) {
                const yearAvg = yearDayData.reduce((sum, d) => sum + d.windSpeed, 0) / yearDayData.length;
                yearlyAvgs.push(yearAvg);
              }
            }
            yearlyAvgByDay[point.name][day] = yearlyAvgs;
          }
        }
      });

      // Update average chart
      const days = Array.from({length: 31}, (_, i) => i + 1);
      const avgDatasets = [];
      
      points.forEach((point, idx) => {
        // Calculate error bar ranges (min and max of yearly averages)
        const errorMin = days.map(day => {
          const yearlyAvgs = yearlyAvgByDay[point.name][day];
          return yearlyAvgs && yearlyAvgs.length > 0 ? Math.min(...yearlyAvgs) : null;
        });
        
        const errorMax = days.map(day => {
          const yearlyAvgs = yearlyAvgByDay[point.name][day];
          return yearlyAvgs && yearlyAvgs.length > 0 ? Math.max(...yearlyAvgs) : null;
        });
        
        // Error bar upper bound
        avgDatasets.push({
          label: `${point.name} error upper`,
          data: errorMax,
          borderColor: colors[idx],
          backgroundColor: colors[idx],
          tension: 0.1,
          spanGaps: true,
          pointRadius: 0,
          borderWidth: 0,
          order: 3,
          fill: false
        });
        
        // Error bar lower bound (fills between upper and lower)
        avgDatasets.push({
          label: `${point.name} (yearly range)`,
          data: errorMin,
          borderColor: colors[idx],
          backgroundColor: colors[idx] + '80', // 80 = 50% opacity
          tension: 0.1,
          spanGaps: true,
          pointRadius: 0,
          borderWidth: 0,
          fill: '-1', // Fill to previous dataset (upper bound)
          order: 3
        });
        
        // Average line (solid) - this is the overall average across all years
        avgDatasets.push({
          label: `${point.name} (avg)`,
          data: days.map(day => avgByDay[point.name][day] || null),
          borderColor: colors[idx],
          backgroundColor: colors[idx],
          tension: 0.1,
          spanGaps: true,
          borderWidth: 2,
          order: 1
        });
        
        // Maximum line (dotted) - instantaneous max within time window
        avgDatasets.push({
          label: `${point.name} (max)`,
          data: days.map(day => maxByDay[point.name][day] || null),
          borderColor: colors[idx],
          backgroundColor: colors[idx],
          tension: 0.1,
          spanGaps: true,
          borderDash: [5, 5],
          borderWidth: 1.5,
          pointRadius: 0,
          order: 2
        });
        
        // Minimum line (dotted) - instantaneous min within time window
        avgDatasets.push({
          label: `${point.name} (min)`,
          data: days.map(day => minByDay[point.name][day] || null),
          borderColor: colors[idx],
          backgroundColor: colors[idx],
          tension: 0.1,
          spanGaps: true,
          borderDash: [5, 5],
          borderWidth: 1.5,
          pointRadius: 0,
          order: 2
        });
      });

      document.getElementById('avgChartTitle').textContent = 
        `Average Wind Speed at 10m (knots) by Day of Month (${monthName} ${startYear}-${endYear}, ${startTime}-${endTime})`;

      if (avgChart) avgChart.destroy();
      const avgCtx = document.getElementById('avgChart').getContext('2d');
      avgChart = new Chart(avgCtx, {
        type: 'line',
        data: {
          labels: days,
          datasets: avgDatasets
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: { 
              position: 'top',
              labels: {
                filter: function(item, chart) {
                  // Hide "error upper" entries from legend
                  return !item.text.includes('error upper');
                }
              }
            },
            tooltip: {
              mode: 'index',
              intersect: false,
              filter: function(tooltipItem) {
                // Hide error bar bounds from tooltip
                return !tooltipItem.dataset.label.includes('error');
              }
            }
          },
          scales: {
            x: {
              title: { display: true, text: 'Day of Month' }
            },
            y: {
              title: { display: true, text: 'Wind Speed (knots)' },
              beginAtZero: true
            }
          }
        }
      });

      // Calculate wind speed distribution (in knots)
      const bins = [0, 3, 6, 9, 12, 15, 18, 21, 24, 100];
      const binLabels = bins.slice(0, -1).map((b, i) => `${b}-${bins[i+1]} kts`);
      
      const distDatasets = points.map((point, idx) => {
        const pointData = weatherData.filter(d => d.pointId === point.id);
        const total = pointData.length;
        const counts = new Array(bins.length - 1).fill(0);
        
        pointData.forEach(d => {
          for (let i = 0; i < bins.length - 1; i++) {
            if (d.windSpeed >= bins[i] && d.windSpeed < bins[i + 1]) {
              counts[i]++;
              break;
            }
          }
        });
        
        const percentages = counts.map(c => (c / total * 100).toFixed(1));
        
        return {
          label: point.name,
          data: percentages,
          backgroundColor: colors[idx],
          borderColor: colors[idx],
          borderWidth: 1
        };
      });

      if (distChart) distChart.destroy();
      const distCtx = document.getElementById('distChart').getContext('2d');
      distChart = new Chart(distCtx, {
        type: 'bar',
        data: {
          labels: binLabels,
          datasets: distDatasets
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: { position: 'top' },
            tooltip: {
              callbacks: {
                label: function(context) {
                  return context.dataset.label + ': ' + context.parsed.y + '%';
                }
              }
            }
          },
          scales: {
            x: {
              title: { display: true, text: 'Wind Speed Range' }
            },
            y: {
              title: { display: true, text: 'Percentage (%)' },
              beginAtZero: true
            }
          }
        }
      });
      
      // Create wind roses
      createWindRoses();
    }

    function getDirectionSector(degrees) {
      // Convert wind direction to 16 sectors
      const sectors = ['N', 'NNE', 'NE', 'ENE', 'E', 'ESE', 'SE', 'SSE', 'S', 'SSW', 'SW', 'WSW', 'W', 'WNW', 'NW', 'NNW'];
      const sectorSize = 360 / 16;
      const index = Math.round(((degrees % 360) / sectorSize)) % 16;
      return sectors[index];
    }

    function createWindRoses() {
      // Clear existing charts
      windRoseCharts.forEach(chart => chart.destroy());
      windRoseCharts = [];
      
      const container = document.getElementById('windRoseContainer');
      container.innerHTML = '';
      
      // Speed bins for wind rose (in knots) with better colors
      const speedBins = [
        { min: 0, max: 5, label: '0-5 kts', color: '#c6e5f5' },
        { min: 5, max: 10, label: '5-10 kts', color: '#73b9e3' },
        { min: 10, max: 15, label: '10-15 kts', color: '#3d8dc9' },
        { min: 15, max: 20, label: '15-20 kts', color: '#1e5a8e' },
        { min: 20, max: 25, label: '20-25 kts', color: '#8b3a8f' },
        { min: 25, max: 100, label: '25+ kts', color: '#d43d51' }
      ];
      
      const directionSectors = ['N', 'NNE', 'NE', 'ENE', 'E', 'ESE', 'SE', 'SSE', 'S', 'SSW', 'SW', 'WSW', 'W', 'WNW', 'NW', 'NNW'];
      
      points.forEach((point, idx) => {
        const pointData = weatherData.filter(d => d.pointId === point.id);
        
        // Calculate frequency for each direction sector and speed bin
        const directionData = {};
        directionSectors.forEach(dir => {
          directionData[dir] = speedBins.map(() => 0);
        });
        
        pointData.forEach(d => {
          const sector = getDirectionSector(d.windDirection);
          const speed = d.windSpeed;
          
          for (let i = 0; i < speedBins.length; i++) {
            if (speed >= speedBins[i].min && speed < speedBins[i].max) {
              directionData[sector][i]++;
              break;
            }
          }
        });
        
        // Convert counts to percentages (non-cumulative)
        const total = pointData.length;
        Object.keys(directionData).forEach(dir => {
          directionData[dir] = directionData[dir].map(count => (count / total * 100));
        });
        
        // Create datasets for each speed bin (from slowest to fastest for proper stacking)
        const datasets = speedBins.map((bin, binIdx) => ({
          label: bin.label,
          data: directionSectors.map(dir => directionData[dir][binIdx]),
          backgroundColor: bin.color + '80', // Add transparency
          borderColor: bin.color,
          borderWidth: 2,
          fill: true,
          pointRadius: 0
        }));
        
        // Create canvas for this point
        const chartDiv = document.createElement('div');
        chartDiv.className = 'bg-white p-4 rounded border';
        chartDiv.innerHTML = `
          <h3 class="font-semibold mb-2" style="color: ${colors[idx]}">${point.name}</h3>
          <div class="flex flex-col items-center">
            <div style="height: 450px; width: 100%; max-width: 450px;">
              <canvas id="windRose${point.id}"></canvas>
            </div>
            <div class="mt-4 flex flex-wrap gap-3 justify-center text-xs">
              ${speedBins.map(bin => `
                <div class="flex items-center gap-1">
                  <div style="width: 16px; height: 16px; background-color: ${bin.color}; border: 1px solid #ccc;"></div>
                  <span>${bin.label}</span>
                </div>
              `).join('')}
            </div>
          </div>
        `;
        container.appendChild(chartDiv);
        
        // Create chart
        const ctx = document.getElementById(`windRose${point.id}`).getContext('2d');
        const chart = new Chart(ctx, {
          type: 'radar',
          data: {
            labels: directionSectors,
            datasets: datasets
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: {
                display: false
              },
              tooltip: {
                callbacks: {
                  label: function(context) {
                    return context.dataset.label + ': ' + context.parsed.r.toFixed(1) + '%';
                  }
                }
              }
            },
            scales: {
              r: {
                beginAtZero: true,
                ticks: {
                  callback: function(value) {
                    return value + '%';
                  },
                  stepSize: 5
                },
                grid: {
                  circular: true
                },
                pointLabels: {
                  font: {
                    size: 12,
                    weight: 'bold'
                  }
                }
              }
            }
          }
        });
        
        windRoseCharts.push(chart);
      });
    }

    // Initialize when page loads
    window.addEventListener('load', function() {
      initMap();
    });
  </script>
</body>
</html>
